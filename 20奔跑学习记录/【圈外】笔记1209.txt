 ----------------- 进程管理----------------- 
 1. 在内核中如何获取当前进程的task_struct 数据结构
 2. 下面程序 会打印几个"_"
 3. 用户空间进程的页表是什么分配的，其中一级页表什么时候分配
 二级页表呢
 4. 请简述对进程调度器的理解，早期linux 内核调度器(包括O(N)和O(1)
 是如何工作的。
 5. 请简述进程优先级，nice值和权重之间的关系 
 6. 请简述CFS调度器是如何工作的。
 7. CFS调度器中vruntime是如何计算的
 8. vruntime是何时更新的。
 9. CFS调度器的min_vruntime有什么作用
10. CFS调度器对新创建的进程和刚唤醒的进程有何关照
11. 如何计算普通进程的平均负载 load_avg_contrib?runnable_avg_sum
和runnable_avg_period分别是什么含义
12. 内核代码中定义了若干个表，请分别说出它们的含义，比如prio_to_weight
prio_to_wmult,runable_avg_yN_inv,runable_avg_yN_sum
13. 如果一个普通进程在就绪队列等待了很长时间才被调度，那么它的平均负载
该如何计算
14. 一个4核处理器中的每个物理CPU拥有独立 L1 cache且不支持超线程技术，
分成两个簇cluser0 和cluster1,每个簇包含两个物理CPU核，族中的CPU核共享
L2 cache.请画出该处理器在linux内核里调度域和调度组的拓扑关系图。
15. 假设CPU0和CPU1同属于一个调度域中且它们都不是ilde cpu,那么CPU1可以
做负载负均衡吗？
16. 如何查找出一个调度域 里最繁忙的调度组？
17. 如果一个调度域负载不均衡，请问如何计算需要迁移多少负载量呢？
18. 使用内核提供的唤醒的进程API，比如wake_up_process来唤醒一个进程，
那么进程唤醒后应该在哪个CPU上运行呢？是调用wake_up_process的那个CPU
，还是之前运行的那个CPU，或者是其他CPU呢？
19. 请问wALT算法是如何计算进程期望运行时间的。
20. EAS调度器如何衡量一个进程的计算能力？
21. 当一个进程被唤醒时，EAS调度器如何选择哪个CPU上运行
22. EAS调度器是否做CPU间的负载均衡呢
23. 目前在linux 4.0内核中，CPU动态调频调压模块CPUfreq和进程调度器之间
如何协同工作的。有什么优缺点
24. 在EAS调度器中，WALT算法计算出来的负载等信息有什么作用？

----------------- 并发与同步----------------- 
 1. 在ARM处理器中，如何实现独占访问内存
 2. atomic_cmpxchg()和atomic_xchg()分别表示什么含义
 3. 为什么spinlock的临界区不能睡眠(不考虑RT-linux的情况）
 4. Linux内核中经典spinlock的实现有什么缺点？
 5. 为什么spinlock临界区不允许发生抢占？
 6. ticket-based的spinlock机制是如何实现的
 7. 如果在spin_lock()和spin_unlock()的临界区中发生了中断，并且中断处理程序
也恰巧修改了该临界资源，那么会发生什么后果？该如何避免呢？
 8. 与spinlock相比，信号时有那些特点？
 9. 请简述信号量是如何实现的。
10. 什么时候使用读者信号量，什么时候使用写者信号量，由什么来判断？
11. 读写信号 量使用的自旋等机制(optimistic spinning)是如何实现的？
12. Linux内核已经实现了信号量机制，为何要单独设置一个mutex机制呢？
13. 请简述MCSe锁机制实现原理 
14. 在编写内核代码时，该如何选择信号量和mutex?
15. RCU相比读写锁有那些优势？
16. 请解释quiescent state和grace period
17. 请简述RCU实现的基本原理
18. 在大型系统中，经典RCU遇到了什么问题？Tree RCU又是如何解决该问题的
19. 在RCU实现中，为什么要使用ULONG_CMP_GE()和ULONG_CMP_LT()宏来比较两
个数的大小，而不直接使用大于号或者小于号来比较。
20. 请简述一个grace period 的生命周期及其状态机的变化
21. 请总结原子操作，spinlock,信号量，读写信号量，mutex和RCU等Linux内核
常用锁的特点和使用规则
22. 在KSM中扫描某个VMA寻找有效的匿名页面，假设此VMA恰巧恰巧被其他CPU
销毁了，会不会有问题呢？
23. 请简述页锁PG_locked的常用使用方法
24. 在mm/rmap.c文件中 page_get_anon_vma()函数中，为什么要使用rcu_read_lock()
什么时候注册RCU回调函数呢
25. 在mm/oom_kill.c的select_bad_process()函数中，为什么要使用rcu_read_lock()
什么时候注册RCU回调函数 呢
----------------- 中断管理------------------------
 1. 发生硬件中断后，ARM处理器做了哪些事情？
 2. 硬件中断号和Linux 内核的IRQ中断号是如何映射的？
 3. 一个硬件中断发生后，Linux内核如何响应并处理该中断？
 4. 为什么说中断上下文不能执行睡眠操作
 5. 软中断的回调函数执行过程中是否允许响应本趣中断
 6. 同一类型的软件中断是否允许多个CPU并行执行
 7. 软件中断上下文件包括那几种情况
 8. 软中断上下文件和进程上下那个优先级高？为什么呢
 9. 是否允许一个tasklet在多个CPU上并行执行？
10. workqueue是运行在中断上下文，还是进程上下文？其回调函数允许睡眠呢？
11. 旧版本(linux 2.6.25) 的workqueue机制在实际过程中遇到那些问题和挑战
12. CMWQ 机制如何动态管理工作线程池的线程呢
13. 如果有多个work 挂入一个工作线程中执行，当某个work的回调函数执行了阻塞
操作，那么剩下的work该怎么办？
