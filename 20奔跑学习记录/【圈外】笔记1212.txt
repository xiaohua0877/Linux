
并发与同步

基础概念
对于SMP系统，情况会更为复杂
(1) 同一类型的中断处理不会并发，但是不同类型的中断有可能送达到不同的CPU上，因此不同
类型的中断处理可能会存在并发执行
(2)同一类型的软中断会在不同的CPU上并发执行
(3)同一类型的tasklet是串行执行的，不会在多个CPU上并发
(4)不同CPU上的进程上下文不会并发

如果有多个内核代码路径可能访问到该数据，那就应该给此数据加以保护。有一个原则要记住：是保护资源或者
数据，而不是保护代码，包括静态局部变量，全局变量，共享的数据结构，Buffer缓存，链表，红黑树等各种形式
所隐含的资源数据。在实现内核代码以及驱动编写过程中，对资源数据需要做如下一些思考
(1) 除了当前内核代码路径外，是否还有其他内核代码路径会访问它？例如中断处理程序，工作者workt 处理程序，
tasklet处理程序，软中断处理程序等
(2) 当前内核代码访问该资源数据时发生被抢占，被调度执行的进程会不会访问该数据
(3) 进程会不会睡眠等待该资源。
   Linux 内核提供多种并发访问的保护机制，例如原子操作，自旋锁，信号量，互体，读写锁，RCU等，
   了解Linux内核中各种锁的实现机制只是第一步，重要的是思考清楚那些地方 是临界区，该用什么机制来保护这些临界
区。

4.1 原子操作与内存屏障


4.1.1 原子操作
    原子操作是指保证指令以原子的方式执行，执行过程不会被打断。

atomic_t 类型的原子变量，它的实现依赖不同体系结构，【include\linux\types.h】
Linux 内核提供了很多原子变量操作的函数
【incldeu\asm-generic\atomic.h】
    ARM使用ldrex 和strex指令保证add操作的原子性，指令后续ex exclusive,
    ARM处理器核心中有local monitor global monitor 来实现ldrex和strex指令的独占访问
    GCC 嵌入式汇编的格式如下__asm__ volatile(指令部：输出部：输入部：损坏部)
    
    ARM GCC 嵌入式操作符和修饰符如表 4.1 所示
4.1.2 内存屏障
    (1) 数据存储屏障 DMB
    (2) 数据同步屏障 DSB   
    (3) 指令同步屏障 ISB
    
    barrier(): 编译优化屏障，阻止编译器为性能优化而进行指令重排
    mb()：内存屏障 包括读和写，用于SMP和UP
    rmb(): 读内存屏障，用于SMP和UP
    wmb(): 写内存屏障，用于SMP和UP
    smp_mb(): 用于SMP场合的内存屏障，对于UP不存在memory order 的问题，
    smp_rmb():用于SMP场合的读内存屏障
    smp_wmb():用于SMP场合的写内存屏障
    smp_read_barrier_depends(): 读依赖屏障
    
    
    [arch\arm\include\asm\barrier.h]
    
    
4.1.2 自旋锁 spinlock
    spinlock 同一时刻只能被一个内核代码路径持有，如果有另外一个内核代码路径试图获取一个已经被持有的
    spinlock,那么该 内核代码路径 需要一直自旋忙等待，直到锁持有者释放了该锁。
    spinlock 锁的特性如下.
    (1) 忙等待的锁机制,操作系统中锁的机制分为两类：一类是忙等待，另一类是睡眠等待，spinlock是属于前者
 当无法获取spinlock锁时不为尝试，直到获取锁为止。
    (2) 同一时刻只能有一个内核代码路径可以获得该锁。
    (3) 要求spinlock锁持有者尽快完成临界区的执行任务。如果临界区执行时间过长。在锁外面忙等待的cpu比较浪费
 特别是spinlock临界区里不能睡眠
    (4)spinlock锁可以在中断上下文使用。
    
    
    
    
    
    
    
    
    
    













 
